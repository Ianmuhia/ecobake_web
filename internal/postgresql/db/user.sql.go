// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: user.sql

package db

import (
	"context"
	"database/sql"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (created_at,
                   user_name,
                   email,
                   phone_number,
                   location,
                   password_hash,
                   profile_image)
VALUES (current_timestamp,
        $2,
        $3,
        $4,
        ST_GeomFromText($1, 4269),
        $5,
        $6)
Returning is_verified, created_at, email, user_name, ST_X(location) AS Longitude, ST_Y(location) AS Latitude, id, updated_at, deleted_at, profile_image, phone_number
`

type CreateUserParams struct {
	StGeomfromtext interface{}    `json:"st_geomfromtext"`
	UserName       string         `json:"user_name"`
	Email          string         `json:"email"`
	PhoneNumber    string         `json:"phone_number"`
	PasswordHash   string         `json:"password_hash"`
	ProfileImage   sql.NullString `json:"profile_image"`
}

type CreateUserRow struct {
	IsVerified   sql.NullBool   `json:"is_verified"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	Email        string         `json:"email"`
	UserName     string         `json:"user_name"`
	Longitude    interface{}    `json:"longitude"`
	Latitude     interface{}    `json:"latitude"`
	ID           int64          `json:"id"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	ProfileImage sql.NullString `json:"profile_image"`
	PhoneNumber  string         `json:"phone_number"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (*CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.StGeomfromtext,
		arg.UserName,
		arg.Email,
		arg.PhoneNumber,
		arg.PasswordHash,
		arg.ProfileImage,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.IsVerified,
		&i.CreatedAt,
		&i.Email,
		&i.UserName,
		&i.Longitude,
		&i.Latitude,
		&i.ID,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProfileImage,
		&i.PhoneNumber,
	)
	return &i, err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE "users"
SET deleted_at = current_timestamp
WHERE id = $1
  AND "users"."deleted_at" IS NULL
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getUnverifiedUserById = `-- name: GetUnverifiedUserById :one
SELECT is_verified,
       created_at,
       email,
       user_name,
       id,
       updated_at,
       deleted_at,
       ST_X(location) AS Longitude,
       ST_Y(location) AS Latitude,
       profile_image,
       password_hash,
       phone_number
FROM "users"
WHERE email = $1
  and is_verified = false
  AND "users"."deleted_at" IS NULL
ORDER BY "users"."id"
LIMIT 1
`

type GetUnverifiedUserByIdRow struct {
	IsVerified   sql.NullBool   `json:"is_verified"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	Email        string         `json:"email"`
	UserName     string         `json:"user_name"`
	ID           int64          `json:"id"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	Longitude    interface{}    `json:"longitude"`
	Latitude     interface{}    `json:"latitude"`
	ProfileImage sql.NullString `json:"profile_image"`
	PasswordHash string         `json:"password_hash"`
	PhoneNumber  string         `json:"phone_number"`
}

func (q *Queries) GetUnverifiedUserById(ctx context.Context, email string) (*GetUnverifiedUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUnverifiedUserById, email)
	var i GetUnverifiedUserByIdRow
	err := row.Scan(
		&i.IsVerified,
		&i.CreatedAt,
		&i.Email,
		&i.UserName,
		&i.ID,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Longitude,
		&i.Latitude,
		&i.ProfileImage,
		&i.PasswordHash,
		&i.PhoneNumber,
	)
	return &i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT is_verified,
       created_at,
       email,
       user_name,
       id,
       profile_image,
       ST_X(location) AS Longitude,
       ST_Y(location) AS Latitude,
       password_hash,
       phone_number
FROM "users"
WHERE email = $1
  AND "users"."deleted_at" IS NULL
ORDER BY "users"."id"
LIMIT 1
`

type GetUserByEmailRow struct {
	IsVerified   sql.NullBool   `json:"is_verified"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	Email        string         `json:"email"`
	UserName     string         `json:"user_name"`
	ID           int64          `json:"id"`
	ProfileImage sql.NullString `json:"profile_image"`
	Longitude    interface{}    `json:"longitude"`
	Latitude     interface{}    `json:"latitude"`
	PasswordHash string         `json:"password_hash"`
	PhoneNumber  string         `json:"phone_number"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (*GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.IsVerified,
		&i.CreatedAt,
		&i.Email,
		&i.UserName,
		&i.ID,
		&i.ProfileImage,
		&i.Longitude,
		&i.Latitude,
		&i.PasswordHash,
		&i.PhoneNumber,
	)
	return &i, err
}

const getUserById = `-- name: GetUserById :one
SELECT is_verified,
       created_at,
       email,
       user_name,
       id,
       updated_at,
       ST_X(location) AS Longitude,
       ST_Y(location) AS Latitude,
       deleted_at,
       profile_image,
       password_hash,
       phone_number
FROM "users"
WHERE id = $1
  AND "users"."deleted_at" IS NULL
ORDER BY "users"."id"
LIMIT 1
`

type GetUserByIdRow struct {
	IsVerified   sql.NullBool   `json:"is_verified"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	Email        string         `json:"email"`
	UserName     string         `json:"user_name"`
	ID           int64          `json:"id"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	Longitude    interface{}    `json:"longitude"`
	Latitude     interface{}    `json:"latitude"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	ProfileImage sql.NullString `json:"profile_image"`
	PasswordHash string         `json:"password_hash"`
	PhoneNumber  string         `json:"phone_number"`
}

func (q *Queries) GetUserById(ctx context.Context, id int64) (*GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.IsVerified,
		&i.CreatedAt,
		&i.Email,
		&i.UserName,
		&i.ID,
		&i.UpdatedAt,
		&i.Longitude,
		&i.Latitude,
		&i.DeletedAt,
		&i.ProfileImage,
		&i.PasswordHash,
		&i.PhoneNumber,
	)
	return &i, err
}

const listUsers = `-- name: ListUsers :many
SELECT is_verified,
       created_at,
       email,
       user_name,
       ST_X(location) AS Longitude,
       ST_Y(location) AS Latitude,
       id,
       updated_at,
       deleted_at,
       profile_image,
       password_hash,
       phone_number
FROM "users"
WHERE "users"."deleted_at" IS NULL
`

type ListUsersRow struct {
	IsVerified   sql.NullBool   `json:"is_verified"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	Email        string         `json:"email"`
	UserName     string         `json:"user_name"`
	Longitude    interface{}    `json:"longitude"`
	Latitude     interface{}    `json:"latitude"`
	ID           int64          `json:"id"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	ProfileImage sql.NullString `json:"profile_image"`
	PasswordHash string         `json:"password_hash"`
	PhoneNumber  string         `json:"phone_number"`
}

func (q *Queries) ListUsers(ctx context.Context) ([]*ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.IsVerified,
			&i.CreatedAt,
			&i.Email,
			&i.UserName,
			&i.Longitude,
			&i.Latitude,
			&i.ID,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProfileImage,
			&i.PasswordHash,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE "users"
SET user_name    = $2,
    email        = $3,
    location     = ST_GeomFromText($1, 4269),
    phone_number = $4
WHERE id = $5
  AND "users"."deleted_at" IS NULL

Returning is_verified , created_at , email , user_name , ST_X(location) AS Longitude , ST_Y(location) AS Latitude , id , updated_at , deleted_at , profile_image , phone_number
`

type UpdateUserParams struct {
	StGeomfromtext interface{} `json:"st_geomfromtext"`
	UserName       string      `json:"user_name"`
	Email          string      `json:"email"`
	PhoneNumber    string      `json:"phone_number"`
	ID             int64       `json:"id"`
}

type UpdateUserRow struct {
	IsVerified   sql.NullBool   `json:"is_verified"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	Email        string         `json:"email"`
	UserName     string         `json:"user_name"`
	Longitude    interface{}    `json:"longitude"`
	Latitude     interface{}    `json:"latitude"`
	ID           int64          `json:"id"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	ProfileImage sql.NullString `json:"profile_image"`
	PhoneNumber  string         `json:"phone_number"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (*UpdateUserRow, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.StGeomfromtext,
		arg.UserName,
		arg.Email,
		arg.PhoneNumber,
		arg.ID,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.IsVerified,
		&i.CreatedAt,
		&i.Email,
		&i.UserName,
		&i.Longitude,
		&i.Latitude,
		&i.ID,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProfileImage,
		&i.PhoneNumber,
	)
	return &i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE "users"
SET password_hash = $1
WHERE id = $2
  and users.deleted_at is null
`

type UpdateUserPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	ID           int64  `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
	return err
}

const updateUserProfileImage = `-- name: UpdateUserProfileImage :one
UPDATE "users"
SET profile_image = $1
WHERE email = $2
  and users.deleted_at is null
Returning is_verified, created_at, email, user_name, ST_X(location) AS Longitude, ST_Y(location) AS Latitude, id, updated_at, deleted_at, profile_image, phone_number
`

type UpdateUserProfileImageParams struct {
	ProfileImage sql.NullString `json:"profile_image"`
	Email        string         `json:"email"`
}

type UpdateUserProfileImageRow struct {
	IsVerified   sql.NullBool   `json:"is_verified"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	Email        string         `json:"email"`
	UserName     string         `json:"user_name"`
	Longitude    interface{}    `json:"longitude"`
	Latitude     interface{}    `json:"latitude"`
	ID           int64          `json:"id"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	ProfileImage sql.NullString `json:"profile_image"`
	PhoneNumber  string         `json:"phone_number"`
}

func (q *Queries) UpdateUserProfileImage(ctx context.Context, arg UpdateUserProfileImageParams) (*UpdateUserProfileImageRow, error) {
	row := q.db.QueryRow(ctx, updateUserProfileImage, arg.ProfileImage, arg.Email)
	var i UpdateUserProfileImageRow
	err := row.Scan(
		&i.IsVerified,
		&i.CreatedAt,
		&i.Email,
		&i.UserName,
		&i.Longitude,
		&i.Latitude,
		&i.ID,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProfileImage,
		&i.PhoneNumber,
	)
	return &i, err
}

const updateUserStatus = `-- name: UpdateUserStatus :one
UPDATE "users"
SET is_verified = true
WHERE email = $1
  and users.deleted_at is null
Returning is_verified, created_at, email, user_name, ST_X(location) AS Longitude, ST_Y(location) AS Latitude, id, updated_at, deleted_at, profile_image, phone_number
`

type UpdateUserStatusRow struct {
	IsVerified   sql.NullBool   `json:"is_verified"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	Email        string         `json:"email"`
	UserName     string         `json:"user_name"`
	Longitude    interface{}    `json:"longitude"`
	Latitude     interface{}    `json:"latitude"`
	ID           int64          `json:"id"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	ProfileImage sql.NullString `json:"profile_image"`
	PhoneNumber  string         `json:"phone_number"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, email string) (*UpdateUserStatusRow, error) {
	row := q.db.QueryRow(ctx, updateUserStatus, email)
	var i UpdateUserStatusRow
	err := row.Scan(
		&i.IsVerified,
		&i.CreatedAt,
		&i.Email,
		&i.UserName,
		&i.Longitude,
		&i.Latitude,
		&i.ID,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProfileImage,
		&i.PhoneNumber,
	)
	return &i, err
}
